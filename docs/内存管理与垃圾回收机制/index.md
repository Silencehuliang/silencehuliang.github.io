# Python学习之路-内存管理


## 简介

Python的内存管理机制可以总结为：引用计数、垃圾回收、内存池。

## 引用计数

引用计数是一种非常高效的内存管理手段， 当一个 Python 对象被引用时其引用计数增加 1， 当其不再被一个变量引用时则计数减 1. 当引用计数等于 0 时对象被删除。

## 垃圾回收

### 引用计数 

引用计数也是一种垃圾收集机制，而且也是一种最直观，最简单的垃圾收集技术。当 Python 的某 

个对象的引用计数降为 0 时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如 

某个新建对象，它被分配给某个引用，对象的引用计数变为 1。如果引用被删除，对象的引用计数为 0， 

那么该对象就可以被垃圾回收。不过如果出现循环引用的话，引用计数机制就不再起有效的作用了 

### 标记清除 

如果两个对象的引用计数都为 1，但是仅仅存在他们之间的循环引用，那么这两个对象都是需要被 

回收的，也就是说，它们的引用计数虽然表现为非 0，但实际上有效的引用计数为 0。所以先将循环引 

用摘掉，就会得出这两个对象的有效计数。 

### 分代回收 

从前面“标记-清除”这样的垃圾收集机制来看，这种垃圾收集机制所带来的额外操作实际上与系统 

中总的内存块的数量是相关的，当需要回收的内存块越多时，垃圾检测带来的额外操作就越多，而垃圾 

回收带来的额外操作就越少；反之，当需回收的内存块越少时，垃圾检测就将比垃圾回收带来更少的额 

外操作。

## 内存池

### 简介

Python 的内存机制呈现金字塔形状，-1，-2 层主要有操作系统进行操作，第 0 层是 C 中的 malloc，free 等内存分配和释放函数进行操作，第 1 层和第 2 层是内存池，有 Python 的接口函数 PyMem_Malloc 函数实现，当对象小于256K 时有该层直接分配内存，第 3 层是最上层，也就是我们对 Python 对象的直接操作。

Python 在运行期间会大量地执行 malloc 和 free 的操作，频繁地在用户态和核心态之间进行切换，这将严重影响 Python 的执行效率。为了加速 Python 的执行效率，Python 引入了一个内存池机制，用于管理对小块内存的申请和释放。

Python 内部默认的小块内存与大块内存的分界点定在 256 个字节，当申请的内存小于 256 字节时，PyObject_Malloc 会在内存池中申请内存；当申请的内存大于 256 字节时，PyObject_Malloc 的行为将蜕化为 malloc 的行为。当然，通过修改 Python 源代码，我们可以改变这个默认值，从而改 变 Python 的默认内存管理行为。 

### 调优手段 

- 手动垃圾回
- 调高垃圾回收阈值
- 避免循环引用（手动解循环引用和使用弱引用） 

### 内存泄露

#### 是什么？

指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。导致程序运行速度减慢甚至系统崩溃等严重后果。 有 __del__() 函数的对象间的循环引用是导致内存泄漏的主凶。 

#### 如何避免？

- 不使用一个对象时使用:del object 来删除一个对象的引用计数就可以有效防止内存泄漏问题。 

- 通过 Python 扩展模块 gc 来查看不能回收的对象的详细信息。 

- 可以通过 sys.getrefcount(obj) 来获取对象的引用计数，并根据返回值是否为 0 来判断是否内存 

泄漏。
